/*****************************************************************************
 *
 * File:    knapsack_simple.c
 * Author:  Alex Stivala
 * Created: April 2009
 *
 * $Id: knapsack_simple.c 4095 2010-08-24 03:26:09Z alexs $
 *
 * simple implementation of knapsack d.p.
 *
 *  Usage: knapsack_simple [-tvn]  < problemspec
 *          -t: show statistics of operations
 *          -v: Verbose output 
 *          -n: assume no name in the first line of the file
 *          -c: show call tree (as (i_caller,w_caller)-(i_callee,w_callee))
 *
 * The problemspec is in the format generated by gen2.c from David Pisinger
 * (http://www.diku.dk/hjemmesider/ansatte/pisinger/codes.html):
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 *
 * Preprocessor symbols:
 *
 * DEBUG          - compile in lots of debugging code.
 * USE_INSTRUMENT - compile in  instrumentation counts.
 *                  Note that if this is not defined, then the -t and -i
 *                  options do not work.
 *
 *****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "bpautils.h"
#include "ht.h"


unsigned int dp_knapsack(unsigned int i, unsigned int w, 
        unsigned int ci, unsigned int cw);

/*****************************************************************************
 *
 * type definitions
 *
 *****************************************************************************/


/* definition of a type for a 2tuple */
/* 
 * The key for the hashtable is a 2-tuple, i.e. we look up by an (i,j)
 * tuple, where i,j would have been the indices of our 2-dimensional matrix
 */
typedef struct tuple2_s 
{
  unsigned int i;
  unsigned int j;
} tuple2_t;


typedef unsigned long counter_t;

typedef struct stats_s 
{
    counter_t reuse;  /* number of times value already found in hashtable */
    counter_t hashcount; /* number of times value computed & stored in ht */
} stats_t;



/* definition of type for an item */
typedef struct item_s
{
    unsigned int profit;
    unsigned int weight;
} item_t;

/*****************************************************************************
 *
 * static data
 *
 *****************************************************************************/

static bool printstats; /* whether to print call stats */
static bool verbose;    /* verbose output  */
static bool showcall;   /* show call tree for -c option */


static unsigned int CAPACITY; /* total capacity for the problem */
static unsigned int NUM_ITEMS; /* number of items */
static item_t *ITEMS;         /* array of item profits and weights (0 unused)*/


#ifdef USE_INSTRUMENT
static stats_t stats;
#endif


/*****************************************************************************
 *
 * static functions
 *
 *****************************************************************************/


/*
 * ht_hash()
 *
 * Compute hash value for the table.
 * We will simply shove the low 16 bits of each index in the tuple
 * into a word and return the value modulo the tablesize.
 *
 * Paramters:
 *     key - ptr to 2-tuple to compute hash value for
 *
 * Return value:
 *     hash value
 */
static unsigned int ht_hash(const void *vkey) 
{
  int hashval;
  const tuple2_t *key = (const tuple2_t *)vkey;

  hashval = (key->i << 16) | (key->j & 0xffff);
  return hashval % HT_SIZE; 

}


/*
 * ht_keymatch()
 *
 * Compare two key structures
 *
 * Parameters:
 *    s1 - key struct ptr for first
 *    s2 - key struct ptr for second
 *
 * Return value:
 *    nonzero if s1 and s2 are equal, else 0.
 *
 */
static int ht_keymatch(const void *vs1, const void *vs2)
{
  const tuple2_t *s1 = (const tuple2_t *)vs1;
  const tuple2_t *s2 = (const tuple2_t *)vs2;

  return (s1->i == s2->i && s1->j == s2->j);
}



/* insert by (i,j) into table */
static void ht_insert_indices(unsigned int i, unsigned int j, 
                                  unsigned int value);

/* lookup by (i,j) */
static bool ht_lookup_indices(unsigned int i, unsigned int j,
                              unsigned int *pvalue);


/*
 * ht_insert_indices()
 *
 * Insert value for (i,j) into the hashtable
 *
 * Parameters:
 *    i,j - indices to build insertion key
 *    value - value to insert for the key
 *
 * Return value:
 *    None.
 */
static void ht_insert_indices(unsigned int i, unsigned int j,
                                  unsigned int value)
{
  tuple2_t key;
  unsigned int uvalue;

  key.i = i;
  key.j = j;
  uvalue = value;
  ht_insert(&key, &uvalue);
}



/*
 * ht_lookup_indices()
 *
 * Get the value for (i,j) from the hashtable
 *
 * Parameters:
 *     i,j - indices to build key for lookup
 *     pvalue - (OUTPUT) value for key, only set if TRUE returned
 * 
 * Return value:
 *     TRUE if found, FALSE otherwise
 */
static bool ht_lookup_indices(unsigned int i, unsigned int j,
                              unsigned int *pvalue)
{
  tuple2_t key;
  unsigned int *pval;

  key.i = i;
  key.j = j;
  pval = (unsigned int *)ht_lookup(&key);
  if (pval)
  {
    *pvalue = *pval;
    return TRUE;
  }
  else
    return FALSE;
}





/*****************************************************************************
 *
 * external functions
 *
 *****************************************************************************/


/*
 * dp_knapsack()
 *
 *
 *      This version is the memory function version; instead of computing
 *      the whole  array bottom-up, it is computed recursively top-down
 *      and values stored in it, and reused (memoization) if already
 *      computed. 
 *
 *      This version uses no bounding.
 *
 *      Parameters:   i - item index
 *                    w - total weight
 *                    ci - caller's value of i (for -c option)
 *                    cw - caller's value of w (for -c option)
 *
 *
 *      Uses global data:
 *                  readonly:
 *                    ITEMS - array of profit and weight for each item
 *
 *                   read/write:
 *                     stats
 *
 *      Return value: 
 *                    value of d.p. at (i,w)
 *
 */
unsigned int dp_knapsack(unsigned int i, unsigned int w,
                         unsigned int ci, unsigned int cw)
{
  static const char *funcname = "dp_knapsack";
  unsigned int p,pwithout,pwith,*pp;

#ifdef DEBUG
  if (showcall)
    bpa_log_msg(funcname, "(%d,%d) - (%d,%d)\n", ci, cw, i, w);
  else
    bpa_log_msg(funcname, "\t%d\t%d\n",i,w);
#endif

  /* memoization: if value here already computed then do nothing */
  if (ht_lookup_indices(i, w, &p))
  {
#ifdef USE_INSTRUMENT
    stats.reuse++;
#endif
    return p;
  }

  if (i == 0 || w == 0)
  {
    p = 0;
  }
  else if (w < ITEMS[i].weight)
  {
    p = dp_knapsack(i - 1, w, i, w);
  }
  else
  {
    pwithout = dp_knapsack(i - 1, w, i, w);
    pwith = dp_knapsack(i - 1, w - ITEMS[i].weight, i, w) + ITEMS[i].profit;
    p = MAX(pwithout, pwith);
  }


#ifdef DEBUG
  bpa_log_msg(funcname, "S\t%d\t%d\t%d\n",i,w,p);
#endif
#ifdef USE_INSTRUMENT
  stats.hashcount++;
#endif
  ht_insert_indices(i, w, p);
  return p;
}


/* 
 * Read the input from stdin in the gen2.c format:
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 * Parameters:
 *     None.
 * Return value:
 *     None.
 * Uses global data (write): 
 *      ITEMS        - allocates array, sets profit and weight for each item
 *      CAPACITY     - sets capacity for problem
 *      NUM_ITEMS   - number of items
 */
static void readdata(void)
{
  unsigned int i,inum;

  if (scanf("%d", &NUM_ITEMS) != 1)
  {
    fprintf(stderr, "ERROR reading number of items\n");
    exit(EXIT_FAILURE);
  }
  ITEMS = (item_t *)bpa_malloc((NUM_ITEMS+1) * sizeof(item_t));
  for (i = 1; i <= NUM_ITEMS; i++)
  {
    if(scanf("%d %d %d", &inum, &ITEMS[i].profit, &ITEMS[i].weight) != 3)
    {
      fprintf(stderr, "ERROR reading item %d\n", i);
      exit(EXIT_FAILURE);
    }
    if (inum != i)
    {
      fprintf(stderr, "ERROR expecting item %d got %d\n", i, inum);
      exit(EXIT_FAILURE);
    }
  }  
  if (scanf("%d", &CAPACITY) != 1)
  {
    fprintf(stderr, "ERROR reading capacity\n");
    exit(EXIT_FAILURE);
  }
}


/* 
 * dump the problem input back to stdout in gen2.c format:
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 * Parameters:
 *     None.
 * Return value:
 *     None.
 * Uses global data (readonly): 
 *      ITEMS        - allocates array, sets profit and weight for each item
 *      CAPACITY     - sets capacity for problem
 *      NUM_ITEMS   - number of items
 */
static void dumpproblem(void)
{
  unsigned int j;
  
  printf("%u\n", NUM_ITEMS);
  for (j = 1; j <= NUM_ITEMS; j++)
  {
    printf("  %d  %u  %u\n", j, ITEMS[j].profit, ITEMS[j].weight);
  }
  printf("%u\n", CAPACITY);
}

/*
 * print usage message and exit
 *
 */
static void usage(const char *program)
{
  fprintf(stderr, 
          "Usage: %s [-tvn]  < problemspec\n"
          "  -n: assume no name in the first line of the file\n"
          "  -t: show statistics of operations\n"
          "  -v: Verbose output\n",
          program);
  
  exit(EXIT_FAILURE);
}




/*
 * main
 */
int main(int argc, char *argv[])
{
  int i = 0;
  char flags[100];
  int c;
  int otime, ttime, etime;
  int profit;
  struct rusage starttime,totaltime,runtime,endtime,opttime;
  struct timeval start_timeval,end_timeval,elapsed_timeval;
  char name[100];
  int noname = 0;

  strcpy(flags, "[NONE]");

  gettimeofday(&start_timeval, NULL);

  while ((c = getopt(argc, argv, "cnvt?")) != -1)
  {
    switch(c) {
      case 'c':
      /* show call tree */
      showcall = 1;
      break;
      case 'v':
	/* verbose output */
	verbose = 1;
        bpa_set_verbose(verbose);
	break;
      case 't':
	/* show stats */
	printstats = 1;
	break;
      case 'n':
        /* no name on first line of input */
        noname = 1;
        break;
      default:
        /* do nothing; ignore unknown optinos */
	break;
    }
    if (i < (int)sizeof(flags)-1)
      flags[i++] = c;
  }

  if (i > 0)
    flags[i] = '\0';

  /* we should have no command line parameters */
  if (optind != argc)
    usage(argv[0]);
  
  if (noname) 
    strcpy(name,"[NONE]\n");
  else
    fgets(name,sizeof(name)-1,stdin);
  
  ht_initialize(sizeof(tuple2_t), sizeof(unsigned int),
                    ht_hash, NULL, 
                    ht_keymatch, NULL);

  getrusage(RUSAGE_SELF, &starttime);

  readdata(); /* read into the ITEMS array and set CAPACITY, NUM_ITEMS */

#ifdef DEBUG
  dumpproblem();
#endif

  profit = dp_knapsack(NUM_ITEMS, CAPACITY, 99999, 99999);

  getrusage(RUSAGE_SELF, &endtime);
  gettimeofday(&end_timeval, NULL);
  timeval_subtract(&elapsed_timeval, &end_timeval, &start_timeval);
  /* timeval_subtract(&endtime,&starttime,&runtime); */
  runtime = endtime;
  ttime = 1000 * runtime.ru_utime.tv_sec + runtime.ru_utime.tv_usec/1000 
          + 1000 * runtime.ru_stime.tv_sec + runtime.ru_stime.tv_usec/1000;
  etime = 1000 * elapsed_timeval.tv_sec + elapsed_timeval.tv_usec/1000;

  printf("%d %lu %lu %d %d %s %s", 
	 profit, 
#ifdef USE_INSTRUMENT
         stats.reuse, stats.hashcount,
#else
         0, 0,
#endif
         ttime, etime, flags, name);

  free(ITEMS);
  exit(0);
  
}
