/*****************************************************************************
 *
 * File:    knapsack_oahttslf.c
 * Author:  Alex Stivala
 * Created: April 2009
 *
 * $Id: knapsack_oahttslf.c 3148 2009-12-27 04:15:31Z alexs $
 *
 * This is the pthreads implementation using the oahttslf lockfree
 * hashtable.
 *
 *
 *  Usage: knapsack_oahttslf [-ntvyz] [-r threads]  < problemspec
 *          -r threads: number of worker threads to run
 *          -t: show statistics of operations
 *          -v: Verbose output 
 *          -n: assume no name in the first line of the file
 *          -y: show instrumentatino summary line (like -t but one line summary)
 *          -z: do NOT randomize choices, make same path in every thread.
 *
 * The problemspec is in the format generated by gen2.c from David Pisinger
 * (http://www.diku.dk/hjemmesider/ansatte/pisinger/codes.html):
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 *
 * Preprocessor symbols:
 *
 * DEBUG          - compile in lots of debugging code.
 * USE_INSTRUMENT - compile in (per-thread) instrumentation counts.
 *                  Note that if this is not defined, then the -t and -i
 *                  options do not work.
 * USE_CONTENTION_INSTRUMENT - compile in (per-thread) oahttslf retry counts
 *****************************************************************************/

#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <getopt.h>
#include <assert.h>
#include <pthread.h>
#include <sys/time.h>
#include <sys/resource.h>

#include "bpautils.h"
#include "oahttslf.h"


unsigned int dp_knapsack(unsigned int i, unsigned int w, int thread_id,
                         unsigned int *seed);

/*****************************************************************************
 *
 * type definitions
 *
 *****************************************************************************/


typedef unsigned long counter_t;

typedef struct stats_s 
{
    counter_t reuse;  /* number of times value already found in hashtable */
    counter_t hashcount; /* number of times value computed & stored in ht */
} stats_t;



/* definition of type for an item */
typedef struct item_s
{
    unsigned int profit;
    unsigned int weight;
} item_t;



/***************************************************************************
 *
 * thread data
 *
 ***************************************************************************/


/* the master thead has id 0 (don't change this; we assume first in array) */
#define MASTER_THREAD_ID 0

typedef struct thread_data_s
{
    int thread_id; /* id of this thread to index into per-thread arrays */
    /* (i,w) for this thread to start at 
     *   i     - item index
     *   w     - total weight
     */
    unsigned int i;
    unsigned int w;
    unsigned int profit;  /* OUTPUT max profit computed by this thread */
} thread_data_t;

#define DEFAULT_MAX_THREADS 4
static unsigned int max_threads = DEFAULT_MAX_THREADS; /* maximum number of worker threads allowed */

/* structures passed to each thread  as parameter */
static thread_data_t thread_data[MAX_NUM_THREADS];

/* pthreads thread handles */
static pthread_t threads[MAX_NUM_THREADS];

/* mutex and condition variable to signal termination so we can wait on
   any thread to terminate in the master, not have to join specific thread */
static pthread_mutex_t term_mutex = PTHREAD_MUTEX_INITIALIZER;
static pthread_cond_t term_cond = PTHREAD_COND_INITIALIZER;
static int term_thread_id = -1;  /* thread_id of finished thread */

/* the number of active threads. This is only used by the master thread */
static unsigned int num_active_threads = 0; /* we do not count the master thread */ 
int active_thread_ids[MAX_NUM_THREADS];

/*****************************************************************************
 *
 * static data
 *
 *****************************************************************************/

static bool printstats; /* whether to print call stats */
static bool verbose;    /* verbose output  */
static bool show_stats_summary = 0; /* -y summary instrumentation stats */
static bool use_random = 1; /* do not randomize choice */


static unsigned int CAPACITY; /* total capacity for the problem */
static unsigned int NUM_ITEMS; /* number of items */
static item_t *ITEMS;         /* array of item profits and weights (0 unused)*/


#ifdef USE_INSTRUMENT
/* per-thread instrumentation */
static stats_t stats[MAX_NUM_THREADS];

/* instrumentatino totals (summed over all threads) */
counter_t  total_reuse = 0, total_hashcount = 0;
#endif


/*****************************************************************************
 *
 * static functions
 *
 *****************************************************************************/


/* insert by (i,j) into table */
static void oahttslf_insert_indices(unsigned int i, unsigned int j, 
                                    unsigned int value, int thread_id);

/* lookup by (i,j) */
static bool oahttslf_lookup_indices(unsigned int i, unsigned int j,
                                     unsigned int *pvalue);

/* dodgy: 0 is the OAHTTSLF_EMPTY_KEY and OAHTTSLF_EMPTY_VALUE value,
   so if key or value is 0 set it to MAGIC_ZERO instead */
#define MAGIC_ZERO 0xffffffffffffffff

/*
 * oahttslf_insert_indices()
 *
 * Insert value for (i,j) into the hashtable
 *
 * Parameters:
 *    i,j - indices to build insertion key
 *    value - value to insert for the key
 *    thread_id - id (0,...n, not pthread id) of this thread
 *
 * Return value:
 *    None.
 */
static void oahttslf_insert_indices(unsigned int i, unsigned int j,
                                    unsigned int value, int thread_id)
{
  uint64_t key, val64;

  key = (i == 0 && j == 0 ? MAGIC_ZERO : 
         ((uint64_t)i << 32) | (j & 0xffffffff));
  val64 = (value == 0 ? MAGIC_ZERO : (uint64_t)value);
  oahttslf_insert(key, val64, thread_id);
}



/*
 * oahttslf_lookup_indices()
 *
 * Get the value for (i,j) from the hashtable
 *
 * Parameters:
 *     i,j - indices to build key for lookup
 *     pvalue - (OUTPUT) value for key, only set if TRUE returned
 * 
 * Return value:
 *     TRUE if found, FALSE otherwise
 */
static bool oahttslf_lookup_indices(unsigned int i, unsigned int j, 
                                    unsigned int *pvalue)
{
  uint64_t key,val64;
  bool found;

  key = (i == 0 && j == 0 ? MAGIC_ZERO :
         ((uint64_t)i << 32) | (j & 0xffffffff));
  found =  oahttslf_lookup(key, &val64);
  if (found)
    *pvalue = ((val64 == MAGIC_ZERO) ? 0 : (unsigned int)val64);
  return found;
}





/*****************************************************************************
 *
 * external functions
 *
 *****************************************************************************/

void *dp_knapsack_thread(void *threadarg);


/*
 * dp_knapsack_thread() - thread interface to dp_knapsack()
 *
 *      This version is multi-threaded, sharing hashtable used to
 *      store computed values between the threads. This function
 *      is just the pthreads interface to the recursive dp_knapsack()
 *      function itself. We compute the value and then signal
 *      a condition variable to indicate the thread has finished,
 *      so the master thread can wait for ANY thread to terminate,
 *      not having to explicitly join a  particular thread.
 *
 *      Parameters:
 *         threadarg - thread data for this thread
 *
 *      Return value:
 *         pointer to int containing max profit value
 *         (declared void* for pthreads).
 *
 */

void *dp_knapsack_thread(void *threadarg)
{
  thread_data_t *mydata = (thread_data_t *)threadarg;

  unsigned int seed = (unsigned int)pthread_self() * time(NULL);
  mydata->profit = dp_knapsack(mydata->i, mydata->w, mydata->thread_id, &seed);

  /* signal thread termination so master can detect a thread finished */
  pthread_mutex_lock(&term_mutex);
  if (term_thread_id == -1) /* master only cares about first thread to exit */
    term_thread_id = mydata->thread_id;
  pthread_cond_signal(&term_cond);
  pthread_mutex_unlock(&term_mutex);
  return &mydata->profit;
}

/*
 * dp_knapsack()
 *
 *      This version is multi-threaded, sharing hashtable used to
 *      store computed values between the threads.
 *      This function is called by dp_knapsack_thread()
 *      with identical instances running
 *      in several threads. This functino itself is recursive
 *      (never creates threads itself) and diverges as there is 
 *      a random choice as to which of the paths we take first; we use
 *      parallelism to explore the search space concurrently with
 *      diverged paths due to this choice, but still reusing computed
 *      values by the shared lock-free hashtable.
 *
 *
 *      This version uses no bounding.
 *
 *      Parameters:   i - item index
 *                    w - total weight
 *            thread_id - our thread identifer (0,1,2,.. NOT pthread_t) 
 *                 seed - seed for rand_r()
 *
 *
 *      Uses global data:
 *                  readonly:
 *                    ITEMS - array of profit and weight for each item
 *
 *                   read/write:
 *                     stats
 *
 *      Return value: 
 *                    value of d.p. at (i,w)
 *
 */
unsigned int dp_knapsack(unsigned int i, unsigned int w, int thread_id,
                         unsigned int *seed)
{
  static const char *funcname = "dp_knapsack";
  unsigned int p,pwithout,pwith;

#ifdef DEBUG
  bpa_log_msg(funcname, "\t%d\t%d\n",i,w);
#endif

  /* memoization: if value here already computed then do nothing */
  if (oahttslf_lookup_indices(i, w, &p))
  {
#ifdef USE_INSTRUMENT
    stats[thread_id].reuse++;
#endif
    return p;
  }

  if (i == 0 || w == 0)
  {
    p = 0;
  }
  else if (w < ITEMS[i].weight)
  {
    p = dp_knapsack(i - 1, w, thread_id, seed);
  }
  else
  {
    if (!use_random || rand_r(seed) % 2)
    {
      pwithout = dp_knapsack(i - 1, w, thread_id, seed);
      pwith = dp_knapsack(i - 1, w - ITEMS[i].weight, thread_id, seed) + 
        ITEMS[i].profit;
    }
    else
    {
      pwith = dp_knapsack(i - 1, w - ITEMS[i].weight, thread_id, seed) +
        ITEMS[i].profit;
      pwithout = dp_knapsack(i - 1, w, thread_id, seed);
    }
    p = MAX(pwithout, pwith);
  }


#ifdef DEBUG
  bpa_log_msg(funcname, "S\t%d\t%d\t%d\n",i,w,p);
#endif
#ifdef USE_INSTRUMENT
  stats[thread_id].hashcount++;
#endif
  oahttslf_insert_indices(i, w, p, thread_id);
  return p;
}



/*
 * dp_knapsack_thread_master()
 *
 *    Caller interafce to the multithreaded version: just calls the actual
 *    implementation in several threads
 *    after setting up thread parameter block.
 *    We do not run it in this thread (thread_id 0, the "master" thread)
 *    itself, as we want to just terminate when the first thread to
 *    compute the answer terminates, since all threads are to compute
 *    the whole problem (don't want the case where we in the
 *    master thread are still computing).
 *
 *
 *    Paramters:
 *        i - item index to start at
 *        w - total capacity to start at
 *
 *    Return value:
 *        min score for this product set
 */
static int dp_knapsack_thread_master(unsigned int i, unsigned int w)
{
  static const char *funcname = "dp_knapsack_thread_master";

  int actindex = 0;
  int new_thread_id;
  int finished_thread_id;
  int rc;
  unsigned int *profit;
  
  term_thread_id = -1;
  num_active_threads = 0; /* do not count master thread */

  while (num_active_threads < max_threads)
  {
#ifdef DEBUG
    fprintf(stderr, "starting thread id %d\n", num_active_threads);
#endif
    new_thread_id = num_active_threads;
    thread_data[num_active_threads].thread_id = num_active_threads;
    thread_data[num_active_threads].i = i;
    thread_data[num_active_threads].w = w;
    if ((rc = pthread_create(&threads[num_active_threads], NULL,
                             dp_knapsack_thread,
                             (void *)&thread_data[num_active_threads])))
      bpa_fatal_error(funcname, "pthread_create() failed (%d)\n", rc);
    active_thread_ids[actindex++] = num_active_threads;
    num_active_threads++;
  }
  
  
  /* in the master thread, wait for first thread to finish (don't care
     about rest) */
  pthread_mutex_lock(&term_mutex);
  /* only wait if no thread has finsished: in POSIX threads, singalling
     a condition before waiting (which happens here if worker thread finishes
     extremely quickly) is a logic error (results in master waiting
     forever on my system) */
  if (term_thread_id == -1)
    pthread_cond_wait(&term_cond, &term_mutex); /*unlocks mutex while waiting*/
  finished_thread_id = term_thread_id;
  pthread_mutex_unlock(&term_mutex);
#ifdef DEBUG
  fprintf(stderr, "thread id %d finished\n", finished_thread_id);
#endif
  if ((rc = pthread_join(threads[finished_thread_id], &profit)))
      bpa_fatal_error(funcname, "pthread_join failed (%d)\n", rc);

  /* TODO cleanup threads (some will still be running) */

  return *profit;
}




#ifdef USE_INSTRUMENT
/*
 * compute_total_counts() 
 *
 *    sum the per-thread stats into total stats
 *
 *
 *      Parameters: None.
 *      Return value: None.
 *      Uses global data:
 *                  read/write:
 *                    total_reuse
 *                    total_hashcount
 *                  readonly:
 *                    stats
 *                    max_threads -max number of threads allowed
 */
static void compute_total_counts()
{
  unsigned int t;
  total_reuse = 0;
  total_hashcount = 0;
  for (t = 0; t < max_threads; t++)
  {
    total_reuse += stats[t].reuse;
    total_hashcount += stats[t].hashcount;
  }
}

#endif


/* 
 * Read the input from stdin in the gen2.c format:
 *
 * numitems
 *      1 profit_1 weight_1
 *      2 profit_2 weight_2  
 *       ...
 *      numitems profit_numitems weight_numitems
 * capacity 
 *
 * all profits and weights are positive integers.
 *
 * Parameters:
 *     None.
 * Return value:
 *     None.
 * Uses global data (write): 
 *      ITEMS        - allocates array, sets profit and weight for each item
 *      CAPACITY     - sets capacity for problem
 *      NUM_ITEMS   - number of items
 */
static void readdata(void)
{
  unsigned int i,inum;

  if (scanf("%d", &NUM_ITEMS) != 1)
  {
    fprintf(stderr, "ERROR reading number of items\n");
    exit(EXIT_FAILURE);
  }
  ITEMS = (item_t *)bpa_malloc((NUM_ITEMS+1) * sizeof(item_t));
  for (i = 1; i <= NUM_ITEMS; i++)
  {
    if(scanf("%d %d %d", &inum, &ITEMS[i].profit, &ITEMS[i].weight) != 3)
    {
      fprintf(stderr, "ERROR reading item %d\n", i);
      exit(EXIT_FAILURE);
    }
    if (inum != i)
    {
      fprintf(stderr, "ERROR expecting item %d got %d\n", i, inum);
      exit(EXIT_FAILURE);
    }
  }  
  if (scanf("%d", &CAPACITY) != 1)
  {
    fprintf(stderr, "ERROR reading capacity\n");
    exit(EXIT_FAILURE);
  }
}

/*
 * print usage message and exit
 *
 */
static void usage(const char *program)
{
  fprintf(stderr, 
          "Usage: %s [-ntvyz] [-r threads] < problemspec\n"
          "  -n: assume no name in the first line of the file\n"
          "  -r threads: number of worker threads to run (default %d)\n"
          "  -t: show statistics of operations\n"
          "  -v: Verbose output\n"
          "  -y: show instrumentatino summary line (like -t but one line summary)\n"
          "  -z: do NOT randomize choices, make same path in every thread\n",
          program, DEFAULT_MAX_THREADS);
  
  exit(EXIT_FAILURE);
}




/*
 * main
 */
int main(int argc, char *argv[])
{
  int i = 0;
  char flags[100];
  int c;
  int otime, ttime, etime;
  int profit;
  struct rusage starttime,totaltime,runtime,endtime,opttime;
  struct timeval start_timeval,end_timeval,elapsed_timeval;
  unsigned int t;
  char name[100];
  int noname = 0;
#ifdef USE_INSTRUMENT
  unsigned int num_keys;
#endif

  strcpy(flags, "[NONE]");

  gettimeofday(&start_timeval, NULL);

  while ((c = getopt(argc, argv, "nvyztr:?")) != -1)
  {
    switch(c) {
      case 'r':
        /* number of worker threads */
        if (atoi(optarg) < 1)
        {
          fprintf(stderr, "number of worker threads must be >= 1\n");
          usage(argv[0]);
        }
        else if (atoi(optarg) > MAX_NUM_THREADS)
        {
          fprintf(stderr, "maximum number of threads is %d\n", MAX_NUM_THREADS);
          usage(argv[0]);
        }
        max_threads = atoi(optarg);
        break;

      case 'v':
	/* verbose output */
	verbose = 1;
        bpa_set_verbose(verbose);
	break;
      case 't':
	/* show stats */
	printstats = 1;
	break;
      case 'n':
        /* no name on first line of input */
        noname = 1;
        break;
      case 'y':
        /* show statistics summaary line of insturmentation */
        show_stats_summary = 1;
        break;
      case 'z':
        /* do not randomize choices */
        use_random = 0;
        break;
      default:
        usage(argv[0]);
   	    break;
    }
    if (i < (int)sizeof(flags)-1)
      flags[i++] = c;
  }

  if (i > 0)
    flags[i] = '\0';

  /* we should have no command line parameters */
  if (optind != argc)
    usage(argv[0]);
  
  if (noname) 
    strcpy(name,"[NONE]\n");
  else
    fgets(name,sizeof(name)-1,stdin);


  getrusage(RUSAGE_SELF, &starttime);

  readdata(); /* read into the ITEMS array and set CAPACITY, NUM_ITEMS */
  profit = dp_knapsack_thread_master(NUM_ITEMS, CAPACITY);

  getrusage(RUSAGE_SELF, &endtime);
  gettimeofday(&end_timeval, NULL);
  timeval_subtract(&elapsed_timeval, &end_timeval, &start_timeval);
  /* timeval_subtract(&endtime,&starttime,&runtime); */
  runtime = endtime;
  ttime = 1000 * runtime.ru_utime.tv_sec + runtime.ru_utime.tv_usec/1000 
          + 1000 * runtime.ru_stime.tv_sec + runtime.ru_stime.tv_usec/1000;
  etime = 1000 * elapsed_timeval.tv_sec + elapsed_timeval.tv_usec/1000;

#ifdef USE_INSTRUMENT
  compute_total_counts();
  num_keys = oahttslf_total_key_count();
#endif

 if (show_stats_summary)
 {
#if defined(USE_INSTRUMENT)
   printf("INSTRUMENT hc=%lu,re=%lu,re/hc=%f,hn=%u,or=%ld\n", total_hashcount, total_reuse,
          (float)total_reuse / total_hashcount, num_keys,
#ifdef USE_CONTENTION_INSTRUMENT
          oahttslf_total_retry_count()
#else
          (long)-1
#endif
          );
#elif defined(USE_CONTENTION_INSTRUMENT)
   printf("INSTRUMENT hc=%lu,re=%lu,re/hc=%f,hn=%u,or=%ld\n", 
           0, 0, 0.0, 0,
          oahttslf_total_retry_count()
          );
#else
   printf("COMPILED WITHOUT -DUSE_INSTRUMENT : NO STATS AVAIL\n");
#endif
 }

#ifdef USE_INSTRUMENT
  if (printstats)
  {
    for (t = 0; t < max_threads; t++)
    {
      printf("thread id %d [re=%lu,hc=%lu,re/hc=%f]\n", t, stats[t].reuse, 
              stats[t].hashcount, (float)stats[t].reuse/stats[t].hashcount);
    }
    printf("totals [re=%lu,hc=%lu,re/hc=%f,hn=%u]\n", total_reuse, total_hashcount,
           (float)total_reuse/total_hashcount, num_keys);
  }
#endif

  printf("%d %d %d %d %d %s %s", 
	 profit, 
#ifdef USE_INSTRUMENT
         total_reuse, total_hashcount,
#else
         0, 0,
#endif
         ttime, etime, flags, name);

  free(ITEMS);
  exit(0);
  
}
